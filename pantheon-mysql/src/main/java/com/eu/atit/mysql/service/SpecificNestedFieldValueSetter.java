package com.eu.atit.mysql.service;

import java.lang.reflect.Field;
import java.util.List;
import java.util.Map;

class SpecificNestedFieldValueSetter<T> {
    final Instantiator<?> instantiator;
    final SpecificFieldValueSetter<?> primaryKeyValueSetter;
    private final FieldValueSetter fieldValueSetter;
    private final ResultSetToInstance<?> resultSetToInstance;

    SpecificNestedFieldValueSetter(Field fieldToSet, ResultSetToInstance<?> resultSetToInstance, Instantiator<?> instantiator, SpecificFieldValueSetter<?> primaryKeyValueSetter) {
        fieldValueSetter = new FieldValueSetter(fieldToSet);
        this.resultSetToInstance = resultSetToInstance;
        this.instantiator = instantiator;
        this.primaryKeyValueSetter = primaryKeyValueSetter;
    }

    public void accept(T setFieldOn, Map<String, Object> row, List<Class<?>> observedClasses) {
        if (!observedClasses.contains(fieldValueSetter.getField().getType())) {
            observedClasses.add(fieldValueSetter.getField().getType());

            fieldValueSetter.accept(setFieldOn, resultSetToInstance.get(row, observedClasses));
        } else { //when we're building an object that has nesting in it in, especially in the form of 1:1 relationships we end up here and prevent infinite objects being generated by lazily initializing an already seen class
            //todo this will cause issues when 1 object(class A) contains references to 2 or more other objects of same type (B type)
            //resolve by observing classes AND their primary keys - this should be enough for deep nestings which are not recursive, i.e. A->B->A2->B2 while also ensuring that true 1:1 mappings don't end up recursive
            Object instance = instantiator.get();
            primaryKeyValueSetter.accept(instance, row);
            fieldValueSetter.accept(setFieldOn, instance);
        }
    }
}
